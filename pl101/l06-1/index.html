<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8">
    <title>Turtle Turtle</title>
</head>

<ul>
<li><p>language </p>

<!-- doc.markdown begin -->
<ul>
<li>C like operators (<code>+</code>, <code>/</code>, <code>?</code>, <code>&amp;&amp;</code>, <code>==</code>, <code>&gt;</code>, etc)</li>
<li>C like scoping (<code>{...}</code>)</li>
<li><code>var x</code>; &#8212; declare a variable x</li>
<li><code>:=</code> &#8212; pascal style assignment operator</li>
<li><code>define f(a, b)</code> &#8212; declare a function <code>f</code> taking parameters <code>a</code>, <code>b</code> </li>
</ul></li>
<li><p>lib turtle procedures</p>

<ul>
<li><code>forward(n)</code> &#8212; draw a line from the pen to <code>n</code> units forward</li>
<li><code>right(d)</code>, <code>left(d)</code> &#8212; rotate left/right by <code>d</code> decimal degrees</li>
<li><code>rot(r)</code> &#8212; rotate by <code>n</code> radians</li>
<li><code>move(x,y)</code> &#8212; move the cursor by (<code>x</code>,<code>y</code>) relative to the pen (including rotations)</li>
<li><code>scale(s)</code> &#8212; scale subsequent commands by <code>s</code></li>
<li><code>scaleXY(x,y)</code> &#8212; scale subsequent commands independently in x and y</li>
<li><code>push()</code> &#8212; save the current state</li>
<li><code>pop()</code> &#8212; restore the lasted pushed state</li>
<li><code>PI</code> &#8212; constant for &pi;</li>
</ul></li>
</ul>
<!-- doc.markdown end -->


<form name="eval" action="">
<input type="button" name="run" value="run" id="run" onclick="doEval()">
<input type="checkbox" name="trace" value="0" id="trace"><label for="trace">log eval trace</label>

<br>
<label for="input">input:</label><br>
<textarea id="input" name="input" rows="20" cols="80">
// Sierpinski triangle (http://en.wikipedia.org/wiki/Sierpinski_triangle)
var numIterations;
numIterations := 6;

define unitTri() {
    forward(1);
    left(120);
    forward(1);
    left(120);
    forward(1);
}

define tri(n) {
    push();
    n := n - 1;
    if (n == 0) unitTri();
    if (n > 0) {
        scale(1/2);
        tri(n);
        move(0, 1);
        tri(n);
        left(120);
        move(0, 1);
        right(120);
        tri(n);
    }
    pop();
}

right(90);
scale(500);
move(-.42, -.5);
tri(numIterations);

</textarea><br>
<div id="turtlecanvas" style="width:600px; height:600px; background-color: #eee;"></div>
<label for="result">result:</label><br>
<textarea id="result" name="result" rows="2" cols="80" readonly></textarea><br>
<!-- label for="output">stdout:</label><br>
<textarea id="output" name="output" rows="8" cols="80" readonly></textarea><br -->
<!--label for="environment">environment:</label><br>
<textarea id="environment" name="environment" rows="8" cols="80" readonly></textarea><br-->
<label for="log">log:</label><br>
<textarea id="log" name="log" rows="16" cols="80" readonly></textarea><br>
</form>

<script src="http://nathansuniversity.com/js/raphael-min.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
    var module = {exports : undefined}
</script>
<script src="turtle.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
    var parseM = module.exports
    var module = {exports : undefined}
</script>
<script src="eval.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
    var evalM = module.exports
    var module = {exports : undefined}
</script>
<script src="libturtle.js" type="text/javascript" charset="utf-8"></script>
<script type="text/javascript" charset="utf-8">
    var libturtleM = module.exports
    var module = {exports : undefined}
    
    var context = Raphael('turtlecanvas');
    
    function doEval() {
        try {
            document.eval.log.value = '';
            var log = function() {
                document.eval.log.value += 
                    Array.prototype.map.call(arguments, function(x){return is_str(x) ? x : JSON.stringify(x)}).join(' ') + "\n";
            }
            var opts = {log : log, trace : document.eval.trace.checked};
            
            libturtleM.init(context);
            context.clear();
            
            // center +ve up
            libturtleM.lib.move(300, 300);
            libturtleM.lib.rot(Math.PI);
            
            opts.env = libturtleM.lib;
            
            document.eval.result.value = JSON.stringify(
                evalM.eval(
                    parseM.parse(document.eval.input.value),
                    opts ) );
            if(document.eval.environment)
                document.eval.environment.value = 
                    envToArray(defEnv.o).map(function(x){
                        return '' + x.n + '\t= ' + 
                            (is_func(x.v) ? x.v.toString() : is_str(x.v) ? x.v: JSON.stringify(x.v))
                        }).join("\n")
        }
        catch(e)
        {
            document.eval.result.value = '';
            document.eval.log.value = e;
            throw e;
        }
    }
</script>

</html>
